## 排序算法  

###### 20160320  

---  
&nbsp;&nbsp;&nbsp;&nbsp;排序总的分为简单排序、快速排序、堆排序、归并排序、基数排序这几种，不同的排序算法有不同的应用场景，各自的排序效率也不相同。为简化排序代码，提高代码的可重用性，特编写一下排序工具类。  
###### SortUti.java  
```java  
/**
 * Created by ljf-梁燕双栖 on 2016/3/19.
 */
public class SortUtil {

    /**
     * 如果v<w,结果返回为true，否则为false
     * @param v
     * @param w
     * @return
     */
    public boolean less(Comparable v, Comparable w) {
        return  v.compareTo(w) < 0 ;
    }

    /**
     * 交换数组中元素
     * @param a
     * @param i
     * @param j
     */
    public void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    public void show(Comparable[] a) {
        for(Comparable c : a) {
            System.out.print(c+"\t");
        }
    }
}  
```  
#### 1 简单排序  
##### 1.1 插入排序  
&nbsp;&nbsp;&nbsp;&nbsp;插入排序属于简单排序中的一种，主要原理是从待排序列的第二个元素开始，与前一个元素比较，如果后一个元素比前一个元素小（以从小到大排序为例），则交换两个元素的位置，继续与前一个比较，直到整个序列完全有序。  

![](img/20160320/01.jpg)  

###### 实现
```java  
/** 插入排数： 从第二个点开始，一直与前面一个点比较，若后面点比前面点小，就将小的点前移，
 *            继续与前面的点比较直到比前面的点大
 *  最好情况 ：待排序的元素已经有序
 *  最坏情况 ：待排序元素时逆序的
 *
 * Created by ljf-梁燕双栖 on 2016/3/19.
 */
public class InseerSort {

    static SortUtil util = new SortUtil();
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int j =1 ; j<N; j++) {
            int i = j -1;
            Comparable key = a[j];
            while (i>=0 && util.less(key, a[i])) {
                a[i+1] = a[i];
                a[i] = key;
                i--;
            }
        }
    }

    public static void main(String[] args) {

        Integer[] a = {5,7,4,3,6,2,10,12,11};
        sort(a);
        util.show(a);
    }
}
```  

##### 1.2 选择排序  
&nbsp;&nbsp;&nbsp;&nbsp; 选择排序的原理是在待排序列中找到最小的那个元素，与序列中第一个元素交换位置，再在剩下的元素中找到最小的元素与，与序列中的第二个元素交换位置，如此往复，直到整个序列有序。  
```java  
/**
 * Created by ljf-梁燕双栖 on 2016/3/19.
 */
public class SelectSort {
    static SortUtil util = new SortUtil();
    public static void sort(Comparable[] a) {
        int N = a.length;
        for(int i = 0; i<N; i++) {
            int min = i;
            for(int j = i+1; j<N; j++)
                if (util.less(a[j],a[min])) min = j;
            util.exch(a,i,min);
        }
    }
    public static void main(String[] args) {

        Integer[] a = {1,5,3,6,8,7,4};
        sort(a);
        util.show(a);
    }

}
```  

###### 算法分析  
&nbsp;&nbsp;&nbsp;&nbsp;简单排序的平均时间复杂度为O（n2）(即O(n*n))，空间复杂度为O(1)，当序列中的记录基本有序或者总体规模n较小时，它是最佳的排序方法；最坏的情况是待排序列是逆序的，最坏情况的时间复杂度也为O(n2).


